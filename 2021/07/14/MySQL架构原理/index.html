<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Mysql架构原理 | 黄自在的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="提起 MySQL，其实网上已经有一大把教程了，为什么我还要写这篇文章呢，大概是因为网上很多网站都是比较零散，而且描述不够直观，不能系统对 MySQL 相关知识有一个系统的学习，导致不能形成知识体系。为此我撰写了这篇文章，试图让这些底层架构相关知识更加直观易懂：  尽量以图文的方式描述技术原理； 涉及到关键的技术，附加官网或者技术书籍来源，方便大家进一步扩展学习； 涉及到的背景知识尽可能做一个交代">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql架构原理">
<meta property="og:url" content="http://example.com/2021/07/14/MySQL%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="黄自在的博客">
<meta property="og:description" content="提起 MySQL，其实网上已经有一大把教程了，为什么我还要写这篇文章呢，大概是因为网上很多网站都是比较零散，而且描述不够直观，不能系统对 MySQL 相关知识有一个系统的学习，导致不能形成知识体系。为此我撰写了这篇文章，试图让这些底层架构相关知识更加直观易懂：  尽量以图文的方式描述技术原理； 涉及到关键的技术，附加官网或者技术书籍来源，方便大家进一步扩展学习； 涉及到的背景知识尽可能做一个交代">
<meta property="og:locale">
<meta property="og:image" content="https://static001.geekbang.org/infoq/23/2367cd8560f06f13a3f7d59399262397.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/51/51fc4e6015adc8c61c22ae8c373c63b0.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/86/8680dd784dc2a32f6e791d359e96b0de.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/b5/b5c82545c62bdc45ccb444709e03be99.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/5e/5e4f805733db974b651ef49a24d11e0d.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/c5/c508ca0f7191418927551e413d6fcf76.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/93/934d1f15b13eb6f800f1ccb9e1cf8d6e.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/6e/6e9b1fbf60de3a7d9b3745a204154050.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/67/674211221fa477bce0be1c64216c8b0a.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/49/49560cf904c66448849ccc780d6fc4f9.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/03/03c4536b36881f553f4edd2e1eec8701.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/d6/d65ae46badc50642a8ef6d89bf93a9a2.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/b4/b4b20012bd6ff54f18d036b34c9dac51.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/d4/d47bf21b689c311b4037499d44bf9aa3.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/58/58accc8453a2aad4f2c8aa7a39a98b18.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/71/715646b8db39a9537925e985c5140c70.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/40/40b49988fae5165d7c3bda8b97bd5811.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/aa/aa9baf9a9b646faa5e2cea311d7f6d59.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/c0/c08ba3394d4b0d0ba15091f832c6dd9b.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/ae/ae2ccab542372899af15f7bd96f075ce.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/54/54e61e95192ef5db3222fd2250a8b41b.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/e9/e9478f2b6b6437599ce100535edc2a73.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/f2/f231c40f96ed9b8c3538b844674421f3.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/41/4165d33aec8fe67b369f5f3b1f26f12d.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/5c/5c81c066e014bc239a8f06058c04fac7.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/71/717bfcf305df41c88d7e65680f899952.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/05/05e74c9848b9ed6bf1b399f0004ec794.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/cf/cfbf40298bf650ae945ed4b1efbf2869.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/cf/cf012b0a6aaba79f340aa860a83b9b16.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/58/586102e0ad6266ff6470f8018bffb24a.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/43/43dff938c76dac4bfb04d29cde06708f.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/98/980bdeb88943b4d724c42d633a075d60.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/f6/f6ce50890fb0ea53c20b78b461c799b2.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/f8/f8a8e4f92d00bf7f8cdb405dfadf8a92.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/0e/0e57c3e6aa3c30ea5c9aaca83e8ed3e3.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/b7/b7d1c7c95da3ad2fbb6a07706bdb1f3e.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/23/23f88bb152b4f0adac684f89e6b587be.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/04/04d37a15176edac0ff0b6931999131e1.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/7c/7ced3b4db0ff7f5bd7d415c187c09aa6.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/f1/f1b622bf440153b664e1bcae91e3c101.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/23/239309e16eb1f1f98b74150a4439bb7f.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/f8/f8d1653e0cc5747edacdd729eb05f2d1.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/7c/7c17313e068d2d5bc3de22b09b211d1a.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/77/77c97883482820562cee431acae481ed.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/61/61715b9558ea807ee055b7338605193a.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/a4/a451cd8380e83917ce8fde3f30c9f93b.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/71/71a6d60e4a95a9ea3d185761b1813fb8.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/49/4947edec75db25fea3cf4e4247b55d6f.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/05/0511164f42c736d04219a23a15575600.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/0c/0c3076a476943d2aa5c3bca36f3c48f4.png">
<meta property="og:image" content="https://static001.geekbang.org/infoq/cc/ccb0ae2eb7184d7109826e07acd3c1b3.png">
<meta property="article:published_time" content="2021-07-13T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-14T06:12:08.174Z">
<meta property="article:author" content="黄自在">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/infoq/23/2367cd8560f06f13a3f7d59399262397.png">
  
    <link rel="alternate" href="/atom.xml" title="黄自在的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">黄自在的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MySQL架构原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/14/MySQL%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2021-07-13T16:00:00.000Z" itemprop="datePublished">2021-07-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Mysql架构原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>提起 MySQL，其实网上已经有一大把教程了，为什么我还要写这篇文章呢，大概是因为网上很多网站都是比较零散，而且描述不够直观，不能系统对 MySQL 相关知识有一个系统的学习，导致不能形成知识体系。为此我撰写了这篇文章，试图让这些底层架构相关知识更加直观易懂：</p>
<ul>
<li>尽量以<code>图文</code>的方式描述技术原理；</li>
<li>涉及到关键的技术，附加<code>官网</code>或者<code>技术书籍</code>来源，方便大家进一步扩展学习；</li>
<li>涉及到的<code>背景知识</code>尽可能做一个交代，比如讨论到 log buffer 的刷盘方式，延伸一下 IO 写磁盘相关知识点。</li>
</ul>
<p>好了，MySQL 从不会到精通系列马上就要开始了（看完之后还是不会的话..请忽略这句话）。</p>
<p>可能会有同学问：为啥不直接学更加先进的 TiDB，或者是强大的 OceanBase。</p>
<p>其实，MySQL 作为老牌的应用场景广泛的关系型开源数据库，其底层架构是很值得我们学习的，吸收其设计精华，那么我们在平时的方案设计工作中也可以借鉴，如果项目中用的是 MySQL，那么就能够把数据库用的更好了，了解了 MySQL 底层的执行原理，对于调优工作也是有莫大帮助的。本文我重点讲述 MySQL 底层架构，涉及到：</p>
<ul>
<li><strong>内存结构</strong>：<code>buffer pool</code>、<code>log buffer</code>、<code>change buffer</code>，buffer pool 的页淘汰机制是怎样的；</li>
<li><strong>磁盘结构</strong>：<code>系统表空间</code>、<code>独立表空间</code>、<code>通用表空间</code>、<code>undo表空间</code>、<code>redo log</code>；</li>
<li>以及<code>IO</code>相关底层原理、查询<code>SQL执行流程</code>、数据<code>页结构</code>和<code>行结构</code>描述、<code>聚集索引</code>和<code>辅助索引</code>的底层数据组织方式、<code>MVCC</code>多版本并发控制的底层实现原理，以及可<code>重复读</code>、<code>读已提交</code>是怎么通过 MVCC 实现的。</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/23/2367cd8560f06f13a3f7d59399262397.png" alt="img"></p>
<p>看完文本文，您将了解到：</p>
<ol>
<li><strong>整体架构：</strong>InnoDB 存储架构是怎样的 (1、MySQL 架构)</li>
<li><strong>工作原理：</strong>查询语句的底层执行流程是怎样的 (2、查询 SQL 执行流程)</li>
<li><strong>IO 性能：</strong>文件<code>IO操作</code>写磁盘有哪几种方式，有什么 IO 优化方式 (3.1.2、关于磁盘 IO 的方式)</li>
<li><strong>缓存：</strong><code>InnoDB缓存</code>(buffer pool, log buffer)的刷新方式有哪些（3.1.2.2、innodb_flush_method）</li>
<li><strong>缓存：</strong>log buffer 是在什么时候写入到磁盘的（3.10.2、如何保证数据不丢失 - 其中第四步 log buffer 持久化到磁盘的时机为）</li>
<li><strong>缓存：</strong>为什么 redo log prepare 状态也要写磁盘？（3.10.2、如何保证数据不丢失 - 为什么第二步 redo log prepare 状态也要写磁盘？）</li>
<li><strong>缓存：</strong>脏页写盘一般发生在什么时候（3.10.2、如何保证数据不丢失 - 其中第五步：脏页刷新到磁盘的时机为）</li>
<li><strong>缓存：</strong>为什么唯一索引的更新不可以借助 change buffer（3.2、Change Buffer）</li>
<li><strong>缓存：</strong><code>log buffer</code>的日志刷盘控制参数<code>innodb_flush_log_at_trx_commit</code>对写性能有什么影响（3.4.1、配置参数）</li>
<li><strong>缓存：</strong>buffer pool 的 LRU 是如何实现的，为什么要这样实现（3.1.1、缓冲池 LRU 算法）</li>
<li><strong>表存储：</strong>系统表空间的结构，MySQL InnoDB 磁盘存储格式，各种<code>表空间</code>(系统表空间，独立表空间，通用表空间)的作用和优缺点是什么，<code>ibdata</code>、<code>ibd</code>、<code>frm</code>文件分别是干嘛的（3.5、表空间）</li>
<li><strong>行字段存储：</strong>底层页和行的存储格式（3.6、InnoDB 底层逻辑存储结构）</li>
<li><strong>行字段存储：</strong><code>varchar</code>，<code>null</code>底层是如何存储的，最大可用存储多大的长度（3.6.3.1、MySQL 中 varchar 最大长度是多少）</li>
<li><strong>行字段存储：</strong>行记录太长了，一页存不下，该怎么存储？（3.6.3.2、行记录超过页大小如何存储）</li>
<li><strong>索引：</strong>数据库<code>索引</code>的组织方式是怎样的，明白为什么要采用<code>B+树</code>，而不是哈希表、二叉树或者 B 树（3.7、索引 - 为什么 MySQL 使用 B+树）</li>
<li><strong>索引：</strong>索引组织方式是怎样的，为什么<code>大字段</code>会影响表性能(查询性能，更新性能)（3.7、索引）</li>
<li><strong>索引：</strong><code>覆盖索引</code>、<code>联合索引</code>什么情况下会生效（3.7.2、辅助索引）</li>
<li><strong>索引：</strong>什么是<code>索引下推</code>，索引下推减少了哪方面的开销？（3.7.2、辅助索引 - 索引条件下推）</li>
<li><strong>索引：</strong><code>Change Buffer</code>对二级索引 DML 语句有什么优化（3.2、Change Buffer）</li>
<li><strong>数据完整性：</strong>MySQL 是如何保证数据完整性的，<code>redo log</code>、<code>undo log</code>和<code>buffer pool</code>数据完整性的关键作用分别是什么（3.10.2、如何保证数据不丢失）</li>
<li><strong>MVCC：</strong><code>MVCC</code>底层是怎么实现的，可重复读和读已提交是怎么实现的（3.11.2、MVCC 实现原理）</li>
<li>双写缓冲区有什么作用（3.9、Doublewrite Buffer）</li>
<li>Redo Log 在一个事务中是在什么时候写入的？binlog 和 Redo Log 有什么区别？（3.10.1、Redo Log 在事务中的写入时机）</li>
</ol>
<h1 id="1、MySQL-架构"><a href="#1、MySQL-架构" class="headerlink" title="1、MySQL 架构"></a>1、MySQL 架构</h1><p>如下图为 MySQL 架构涉及到的常用组件：</p>
<p><img src="https://static001.geekbang.org/infoq/51/51fc4e6015adc8c61c22ae8c373c63b0.png" alt="img"></p>
<h1 id="2、查询-SQL-执行流程"><a href="#2、查询-SQL-执行流程" class="headerlink" title="2、查询 SQL 执行流程"></a>2、查询 SQL 执行流程</h1><p>有如下表格：</p>
<p><img src="https://static001.geekbang.org/infoq/86/8680dd784dc2a32f6e791d359e96b0de.png" alt="img"></p>
<p>我们执行以下 sql：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where user_id&#x3D;10000;</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<h2 id="2-1、MySQL-客户端与服务器建立连接"><a href="#2-1、MySQL-客户端与服务器建立连接" class="headerlink" title="2.1、MySQL 客户端与服务器建立连接"></a>2.1、MySQL 客户端与服务器建立连接</h2><p>如下图，建立过程：</p>
<ul>
<li>客户端通过 mysql 命令发起连接请求；</li>
<li>经过三次握手后与服务端建立 TCP 连接；</li>
<li>连接器接收到请求之后使用用户密码进行身份验证；</li>
<li>验证通过之后，获取用户的权限信息缓存起来，<strong>该连接后面都是基于该缓存中的权限执行 sql</strong>；</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/b5/b5c82545c62bdc45ccb444709e03be99.png" alt="img"></p>
<p>对于 Java 应用程序来说，一般会把建立好的连接放入数据库连接池中进行复用，只要这个连接不关闭，就会一直在 MySQL 服务端保持着，可以通过<code>show processlist</code>命令查看，如下：</p>
<p><img src="https://static001.geekbang.org/infoq/5e/5e4f805733db974b651ef49a24d11e0d.png" alt="img"></p>
<p>注意，这里有个 Time，表示这个连接多久没有动静了，上面例子是 656 秒没有动静，<strong>默认地，如果超过 8 个小时还没有动静，连接器就会自动断开连接</strong>，可以通过<code>wait_timeout</code>参数进行控制。</p>
<h2 id="2-2、执行-SQL"><a href="#2-2、执行-SQL" class="headerlink" title="2.2、执行 SQL"></a>2.2、执行 SQL</h2><p>如下图，执行 sql：</p>
<p><img src="https://static001.geekbang.org/infoq/c5/c508ca0f7191418927551e413d6fcf76.png" alt="img"></p>
<ul>
<li>服务端接收到客户端的查询 sql 之后，先尝试从查询缓存中查询该 sql 是否已经有缓存的结果了，如果有则直接返回结果，如果没有则执行下一步；</li>
<li>分析器拿到 sql 之后会尝试对 sql 语句进行词法分析和语法分析，校验语法的正确性，通过之后继续往下执行；</li>
<li>优化器拿到分析器的 sql 之后，开始继续解析 sql，判断到需要走什么索引，根据实际情况重写 sql，最终生成执行计划；</li>
<li>执行器根据执行计划执行 sql，执行之前会先进行操作权限校验；然后根据表存储引擎调用对饮接口进行查询数据，这里的扫描行数就是指的接口返回的记录数，执行器拿到返回记录之后进一步加工，如本例子：</li>
<li>执行器拿到 select * from t_user where user_id=10000 的所有记录，在依次判断 user_name 是不是等于”arthinking”，获取到匹配的记录。</li>
</ul>
<h1 id="3、InnoDB-引擎架构"><a href="#3、InnoDB-引擎架构" class="headerlink" title="3、InnoDB 引擎架构"></a>3、InnoDB 引擎架构</h1><p>如下图，为存储引擎的架构：</p>
<p><img src="https://static001.geekbang.org/infoq/93/934d1f15b13eb6f800f1ccb9e1cf8d6e.png" alt="img"></p>
<p>其实内存中的结构不太好直接观察到，不过磁盘的还是可以看到的，我们找到磁盘中 MySQL 的数据文件夹看看：</p>
<p><code>cd innodb_data_home_dir</code> 查看 MySQL 数据目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|- ib_buffer_pool  &#x2F;&#x2F; 保存缓冲池中页面的表空间ID和页面ID，用于重启恢复缓冲池  |- ib_logfile0  &#x2F;&#x2F; redo log 磁盘文件1  |- ib_logfile1  &#x2F;&#x2F; redo log 磁盘文件2，默认情况下，重做日志存在磁盘的这两个文件中，循环的方式写入重做日志  |- ibdata1  &#x2F;&#x2F; 系统表空间文件  |- ibtmp1  &#x2F;&#x2F; 默认临时表空间文件，可通过innodb_temp_data_file_path属性指定文件位置  |- mysql&#x2F;  |- mysql-bin.000001  &#x2F;&#x2F; bin log文件  |- mysql-bin.000001  &#x2F;&#x2F; bin log文件  ... |- mysql-bin.index  &#x2F;&#x2F; bin log文件索引 |- mysqld.local.err  &#x2F;&#x2F; 错误日志 |- mysqld.local.pid  &#x2F;&#x2F; mysql进程号 |- performance_schema&#x2F;  &#x2F;&#x2F; performance_schema数据库 |- sys&#x2F;  &#x2F;&#x2F; sys数据库 |- test&#x2F;  &#x2F;&#x2F; 数据库文件夹     |- db.opt  &#x2F;&#x2F; test数据库配置文件，包含数据库字符集属性     |- t.frm  &#x2F;&#x2F; 数据表元数据文件，不管是使用独立表空间还是系统表空间，每个表都对应有一个     |- t.ibd  &#x2F;&#x2F; 数据库表独立表空间文件，如果使用的是独立表空间，则一个表对应一个ibd文件，否则保存在系统表空间文件中</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-30">30]</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/innodb-preload-buffer-pool.html">ib_buffer_pool</a>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-31">31]</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html">ib_logfile0</a>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-32">32]</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-temporary-tablespace.html">ibtmp1</a>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-33">33]</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/data-dictionary-file-removal.html">db.opt</a>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-34">34]</a></p>
<p>接下来我们逐一来介绍。</p>
<h2 id="3-1、buffer-pool"><a href="#3-1、buffer-pool" class="headerlink" title="3.1、buffer pool"></a>3.1、buffer pool</h2><p><img src="https://static001.geekbang.org/infoq/6e/6e9b1fbf60de3a7d9b3745a204154050.png" alt="img"></p>
<p><code>buffer pool</code>（<code>缓冲池</code>）是<code>主内存</code>中的一个区域，在 InnoDB 访问<code>表数据</code>和<code>索引数据</code>的时候，会顺便把对应的数据页缓存到缓冲池中。如果直接从缓冲池中直接读取数据将会加快处理速度。在专用服务器上，通常将 80%左右的物理内存分配给缓冲池。</p>
<p>为了提高缓存管理效率，缓冲池把页面链接为列表，使用<code>改进版的LRU算法</code>将很少使用的数据从缓存中老化淘汰掉。</p>
<h3 id="3-1-1、缓冲池-LRU-算法"><a href="#3-1-1、缓冲池-LRU-算法" class="headerlink" title="3.1.1、缓冲池 LRU 算法"></a><em>3.1.1、缓冲池 LRU 算法</em></h3><p>通过使用改进版的 LRU 算法来管理缓冲池列表。</p>
<p>当需要把新页面存储到缓冲池中的时候，将淘汰最近最少使用的页面，并将新页面添加到旧子列表的头部。</p>
<p><img src="https://static001.geekbang.org/infoq/67/674211221fa477bce0be1c64216c8b0a.png" alt="img"></p>
<p>该算法运行方式：</p>
<ul>
<li>默认 3/8 缓冲池用于旧子列表；</li>
<li>当新页面如缓冲池时，<strong>首先将其插入旧子列表头部</strong>；</li>
<li>重复访问旧子列表的页面，将使其移动至新子列表的头部；</li>
<li>随着数据库的运行，页面逐步移至列表尾部，缓冲池中未被方位的页面最终将被老化淘汰。</li>
</ul>
<p>相关优化参数：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_pct"><code>innodb_old_blocks_pct</code></a>：控制 LRU 列表中旧子列表的百分比，默认是 37，也就是 3/8，可选范围为 5~95；</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_old_blocks_time"><code>innodb_old_blocks_time</code></a> ：指定第一次访问页面后的时间窗口，该时间窗口内访问页面不会使其移动到 LRU 列表的最前面。默认是 1000，也就是 1 秒。</li>
</ul>
<blockquote>
<p><strong>innodb_old_blocks_time</strong> 很重要，有了这 1 秒，对于全表扫描，由于是顺序扫描的，一般同一个数据页的数据都是在一秒内访问完成的，不会升级到新子列表中，一直在旧子列表淘汰数据，所以不会影响到新子列表的缓存。</p>
</blockquote>
<h3 id="3-1-2、关于磁盘-IO-的方式"><a href="#3-1-2、关于磁盘-IO-的方式" class="headerlink" title="3.1.2、关于磁盘 IO 的方式"></a><em>3.1.2、关于磁盘 IO 的方式</em></h3><p><img src="https://static001.geekbang.org/infoq/49/49560cf904c66448849ccc780d6fc4f9.png" alt="img"></p>
<p><code>O_DIRECT</code>是<code>innodb_flush_method</code>参数的一个可选值。</p>
<p>这里先介绍下和数据库性能密切相关的文件 IO 操作方法</p>
<h4 id="3-1-2-1、文件-IO-操作方法"><a href="#3-1-2-1、文件-IO-操作方法" class="headerlink" title="3.1.2.1、文件 IO 操作方法"></a>3.1.2.1、文件 IO 操作方法</h4><p>数据库系统是基于文件系统的，其性能和设备读写的机制有密切的关系。</p>
<h5 id="open：打开文件-1"><a href="#open：打开文件-1" class="headerlink" title="open：打开文件[1]"></a>open：打开文件[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-1">1]</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>系统调用 Open 会为该进程一个文件描述符 fd，常用的 flags 如下：</p>
<ul>
<li><code>O_WRONLY</code>：表示我们以”写”的方式打开，告诉内核我们需要向文件中写入数据；</li>
<li><code>O_DSYNC</code>：每次 write 都等待物理 I/O 完成，但是如果写操作不影响读取刚写入的数据，则不等待文件属性更新；</li>
<li><code>O_SYNC</code>：每次 write 都等到物理 I/O 完成，包括 write 引起的文件属性的更新；</li>
<li><code>O_DIRECT</code>：执行磁盘 IO 时绕过缓冲区高速缓存(内核缓冲区)，从用户空间直接将数据传递到文件或磁盘设备，称为直接 IO（direct IO）。因为没有了 OS cache，所以会 O_DIRECT 降低文件的顺序读写的效率。</li>
</ul>
<h5 id="write：写文件-2"><a href="#write：写文件-2" class="headerlink" title="write：写文件^2"></a>write：写文件<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/[man-pages.write.">^2</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>使用 open 打开文件获取到文件描述符之后，可以调用 write 函数来写文件，具体表现根据 open 函数参数的不同而不同弄。</p>
<h5 id="fsync-amp-fdatasync：刷新文件-3"><a href="#fsync-amp-fdatasync：刷新文件-3" class="headerlink" title="fsync &amp; fdatasync：刷新文件[3]"></a>fsync &amp; fdatasync：刷新文件[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-3">3]</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int fsync(int fd);</span><br><span class="line">int fdatasync(int fd);</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<ul>
<li><code>fdatasync</code>：操作完 write 之后，我们可以调用 fdatasync 将文件数据块 flush 到磁盘，只要 fdatasync 返回成功，则可以认为数据已经写到磁盘了；</li>
<li><code>fsync</code>：与 O_SYNC 参数类似，fsync 还会更新文件 metadata 到磁盘；</li>
<li><code>sync</code>：sync 只是将修改过的块缓冲区写入队列，然后就返回，不等实际写磁盘操作完成；</li>
</ul>
<p><strong>为了保证文件更新成功持久化到硬盘，除了调用 write 方法，还需要调用 fsync。</strong></p>
<p>大致交互流程如下图：</p>
<p><img src="https://static001.geekbang.org/infoq/03/03c4536b36881f553f4edd2e1eec8701.png" alt="img"></p>
<p>更多关于磁盘 IO 的相关内容，可以阅读：<a target="_blank" rel="noopener" href="https://medium.com/databasss/on-disk-io-part-1-flavours-of-io-8e1ace1de017">On Disk IO, Part 1: Flavors of IO</a>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-27">27]</a></p>
<p><strong>fsync 性能问题：</strong>除了刷脏页到磁盘，fsync 还会同步文件 metadata，而文件数据和 metadata 通常存放在磁盘不同地方，所以 fsync 至少需要两次 IO 操作。</p>
<p><strong>对 fsync 性能的优化建议</strong>：由于以上性能问题，如果能够减少 metadata 的更新，那么就可以使用 fdatasync 了。因此需要确保文件的尺寸在 write 前后没有发生变化。为此，可以创建固定大小的文件进行写，写完则开启新的文件继续写。</p>
<h4 id="3-1-2-2、innodb-flush-method"><a href="#3-1-2-2、innodb-flush-method" class="headerlink" title="3.1.2.2、innodb_flush_method"></a>3.1.2.2、innodb_flush_method</h4><p><code>innodb_flush_method</code>定义用于将数据<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_flush">刷新</a>到<code>InnoDB</code><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_data_files">数据文件</a>和<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_log_file">日志文件的方法</a>，这可能会影响 I/O 吞吐量。</p>
<p>以下是具体参数说明：</p>
<p><img src="https://static001.geekbang.org/infoq/d6/d65ae46badc50642a8ef6d89bf93a9a2.png" alt="img"></p>
<p>比较常用的是这三种：</p>
<h5 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h5><p>默认值，使用<code>fsync()</code>系统调用来 flush 数据文件和日志文件到磁盘；</p>
<h5 id="O-DSYNC"><a href="#O-DSYNC" class="headerlink" title="O_DSYNC"></a>O_DSYNC</h5><p>由于 open 函数的 O_DSYNC 参数在许多 Unix 系统上都存中问题，因此 InnoDB 不直接使用 O_DSYNC。</p>
<p><code>InnoDB</code>用于<code>O_SYNC</code> 打开和刷新日志文件，<code>fsync()</code>刷新数据文件。</p>
<p>表现为：写日志操作是在 write 函数完成，数据文件写入是通过<code>fsync()</code>系统调用来完成；</p>
<h5 id="O-DIRECT"><a href="#O-DIRECT" class="headerlink" title="O_DIRECT"></a>O_DIRECT</h5><p>使用<code>O_DIRECT</code> （在 Solaris 上对应为<code>directio()</code>）打开数据文件，并用于<code>fsync()</code>刷新数据文件和日志文件。此选项在某些 GNU/Linux 版本，FreeBSD 和 Solaris 上可用。</p>
<p>表现为：数据文件写入直接从 buffer pool 到磁盘，不经过操作系统缓冲，日志还是需要经过操作系统缓存；</p>
<h5 id="O-DIRECT-NO-FSYNC"><a href="#O-DIRECT-NO-FSYNC" class="headerlink" title="O_DIRECT_NO_FSYNC"></a>O_DIRECT_NO_FSYNC</h5><p>在刷新 I/O 期间<code>InnoDB</code>使用<code>O_DIRECT</code>，并且每次 write 操作后跳过<code>fsync()</code>系统调用。</p>
<p>此设置适用于某些类型的文件系统，但不适用于其他类型的文件系统。例如，它不适用于 XFS。如果不确定所使用的文件系统是否需要 fsync()（例如保留所有文件元数据），请改用 O_DIRECT。</p>
<p>如下图所示：</p>
<p><img src="https://static001.geekbang.org/infoq/b4/b4b20012bd6ff54f18d036b34c9dac51.png" alt="img"></p>
<blockquote>
<p><strong>为什么使用了 O_DIRECT 配置后还需要调用 fsync()?</strong></p>
<p>参考 MySQL 的这个 bug：<a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=45892">Innodb calls fsync for writes with innodb_flush_method=O_DIRECT</a>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-35">35]</a></p>
<p>Domas 进行的一些测试表明，如果没有 fsync，某些文件系统（XFS）不会同步元数据。如果元数据会更改，那么您仍然需要使用 fsync（或 O_SYNC 来打开文件）。</p>
<p>例如，如果在启用 O_DIRECT 的情况下增大文件大小，它仍将写入文件的新部分，但是由于元数据不能反映文件的新大小，因此如果此刻系统发生崩溃，文件尾部可能会丢失。</p>
<p>为此：<strong>当重要的元数据发生更改时，请继续使用 fsync 或除 O_DIRECT 之外，也可以选择使用 O_SYNC。</strong></p>
</blockquote>
<p>MySQL 从 v5.6.7 起提供了<code>O_DIRECT_NO_FSYNC</code>选项来解决此类问题。</p>
<h2 id="3-2、Change-Buffer"><a href="#3-2、Change-Buffer" class="headerlink" title="3.2、Change Buffer"></a>3.2、Change Buffer</h2><p>change buffer 是一种特殊的数据结构，当<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_secondary_index">二级索引</a>页(非唯一索引)不在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_buffer_pool">缓冲池中</a>时，它们会缓存这些更改 。当页面通过其他读取操作加载到缓冲池中时，再将由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/insert.html">INSERT</a>，<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/update.html">UPDATE</a>或<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/delete.html">DELETE</a>操作（DML）产生的 change buffer 合并到 buffer pool 的数据页中。</p>
<blockquote>
<p><strong>为什么唯一索引不可以使用 chage buffer？</strong></p>
<p>针对唯一索引，如果 buffer pool 不存在对应的数据页，还是需要先去磁盘加载数据页，才能判断记录是否重复，这一步避免不了。</p>
<p>而普通索引是非唯一的，插入的时候以相对随机的顺序发生，删除和更新也会影响索引树中不相邻的二级索引树，<strong>通过使用合并缓冲，避免了在磁盘产生大量的随机 IO 访问获取普通索引页。</strong></p>
<p><strong>问题</strong></p>
<p>当有许多受影响的行和许多辅助索引要更新时，change buffer 合并可能需要几个小时，在此期间，I/O 会增加，可能会导致查询效率大大降低，即使在事务提交之后，或者服务器重启之后，change buffer 合并操作也会继续发生。相关阅读：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/forcing-innodb-recovery.html">Section 14.22.2, “Forcing InnoDB Recovery”</a></p>
</blockquote>
<h2 id="3-3、自适应哈希索引"><a href="#3-3、自适应哈希索引" class="headerlink" title="3.3、自适应哈希索引"></a>3.3、自适应哈希索引</h2><p>自适应哈希索引功能由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index">innodb_adaptive_hash_index</a>变量启用 ，或在服务器启动时由<code>--skip-innodb-adaptive-hash-index</code>禁用。</p>
<h2 id="3-4、Log-Buffer"><a href="#3-4、Log-Buffer" class="headerlink" title="3.4、Log Buffer"></a>3.4、Log Buffer</h2><p>log buffer(日志缓冲区)用于保存要写入磁盘上的 log file(日志文件)的数据。日志缓存区的内容会定期刷新到磁盘。</p>
<p>日志缓冲区大小由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size">innodb_log_buffer_size</a>变量定义 。默认大小为 16MB。较大的日志缓冲区可以让大型事务在提交之前无需将 redo log 写入磁盘。</p>
<p>如果您有更新，插入或者删除多行的事务，尝试增大日志缓冲区的大小可以节省磁盘 I/O。</p>
<h3 id="3-4-1、配置参数"><a href="#3-4-1、配置参数" class="headerlink" title="3.4.1、配置参数"></a><em>3.4.1、配置参数</em></h3><p><strong>innodb_flush_log_at_trx_commit</strong></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a> 变量控制如何将日志缓冲区的内容写入并刷新到磁盘。</p>
<p>该参数控制是否严格存储 ACID 还是尝试获取更高的性能，可以通过该参数获取更好的性能，但是会导致在系统崩溃的过程中导致数据丢失。</p>
<p>可选参数：</p>
<ul>
<li>0，事务提交之后，日志只记录到 log buffer 中，每秒写一次日志到缓存并刷新到磁盘，尚未刷新的日志可能会丢失；</li>
<li>1，要完全符合 ACID，必须使用该值，表示日志在每次事务提交时写入缓存并刷新到磁盘；</li>
<li>2，每次事务提交之后，日志写到 page cache，每秒刷一次到磁盘，尚未刷新的日志可能会丢失；</li>
</ul>
<p><strong>innodb_flush_log_at_timeout</strong></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout">innodb_flush_log_at_timeout</a> 变量控制日志刷新频率。可让您将日志刷新频率设置为*<code>N</code><em>秒（其中</em><code>N</code>*为<code>1 ... 2700</code>，默认值为 1）</p>
<blockquote>
<p>为了保证数据不丢失，请执行以下操作：</p>
<ul>
<li>如果启用了 binlog，则设置：sync_binlog=1;</li>
<li>innodb_flush_log_at_trx_commit=1;</li>
</ul>
</blockquote>
<p>配置效果如下图所示：</p>
<p><img src="https://static001.geekbang.org/infoq/d4/d47bf21b689c311b4037499d44bf9aa3.png" alt="img"></p>
<h2 id="3-5、表空间"><a href="#3-5、表空间" class="headerlink" title="3.5、表空间"></a>3.5、表空间</h2><p>一个<code>InnoDB</code>表及其索引可以在建在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace">系统表空间</a>中，或者是在一个 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_file_per_table">独立表空间</a> 中，或在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_general_tablespace">通用表空间</a>。</p>
<ul>
<li>当<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a>启用时，通常是将表存放在独立表空间中，这是默认配置；</li>
<li>当<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a>禁用时，则会在系统表空间中创建表；</li>
<li>要在通用表空间中创建表，请使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html"><code>CREATE TABLE … TABLESPACE</code></a>语法。有关更多信息，请参见官方文档 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/general-tablespaces.html">14.6.3.3 General Tablespaces</a>。</li>
</ul>
<p>表空间概览图：</p>
<p><img src="https://static001.geekbang.org/infoq/58/58accc8453a2aad4f2c8aa7a39a98b18.png" alt="img"></p>
<h3 id="表空间涉及的文件"><a href="#表空间涉及的文件" class="headerlink" title="表空间涉及的文件"></a><em>表空间涉及的文件</em></h3><p>相关文件默认在磁盘中的<code>innodb_data_home_dir</code>目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|- ibdata1  &#x2F;&#x2F; 系统表空间文件|- ibtmp1  &#x2F;&#x2F; 默认临时表空间文件，可通过innodb_temp_data_file_path属性指定文件位置|- test&#x2F;  &#x2F;&#x2F; 数据库文件夹    |- db.opt  &#x2F;&#x2F; test数据库配置文件，包含数据库字符集属性    |- t.frm  &#x2F;&#x2F; 数据表元数据文件，不管是使用独立表空间还是系统表空间，每个表都对应有一个    |- t.ibd  &#x2F;&#x2F; 数据库表独立表空间文件，如果使用的是独立表空间，则一个表对应一个ibd文件，否则保存在系统表空间文件中</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p><strong>frm 文件</strong></p>
<p>创建一个<code>InnoDB</code>表时，MySQL 在数据库目录中创建一个<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_frm_file">.frm文件</a>。frm 文件包含 MySQL 表的元数据(如表定义)。每个 InnoDB 表都有一个.frm 文件。</p>
<p>与其他 MySQL 存储引擎不同， <code>InnoDB</code>它还在<code>系统表空间</code>内的自身内部数据字典中编码有关表的信息。MySQL 删除表或数据库时，将删除一个或多个<code>.frm</code>文件以及<code>InnoDB</code>数据字典中的相应条目。</p>
<p>因此，在 InnoDB 中，您不能仅通过移动<code>.frm</code> 文件来移动表。有关移动<code>InnoDB</code> 表的信息，请参见官方文档<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-migration.html">14.6.1.4 Moving or Copying InnoDB Tables</a>。</p>
<p><strong>ibd 文件</strong></p>
<p>对于在独立表空间创建的表，还会在数据库目录中生成一个 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_ibd_file">.ibd</a>表空间文件。</p>
<p>在<code>通用表空间</code>中创建的表在现有的常规表空间 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_ibd_file">.ibd文件</a>中创建。常规表空间文件可以在 <strong>MySQL 数据目录内部或外部创建</strong>。有关更多信息，请参见官方文档<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/general-tablespaces.html">14.6.3.3 General Tablespaces</a>。</p>
<p><strong>ibdata 文件</strong></p>
<p>系统表空间文件，在 <code>InnoDB</code>系统表空间中创建的表在 ibdata 中创建。</p>
<h3 id="3-5-1、系统表空间"><a href="#3-5-1、系统表空间" class="headerlink" title="3.5.1、系统表空间"></a><em>3.5.1、系统表空间</em></h3><p>系统表空间由一个或多个数据文件(ibdata 文件)组成。其中包含与<code>InnoDB</code>相关对象有关的元数据（<code>InnoDB</code> <strong>数据字典</strong> <strong>data dictionary</strong>），以及<strong>更改缓冲区</strong>（<strong>change buffer</strong>）， <strong>双写缓冲区</strong>（<strong>doublewrite buffer</strong>）和<strong>撤消日志</strong>（<strong>undo logs</strong>）的存储区 。</p>
<p><code>InnoDB</code> 如果表是在系统表空间中创建的，则系统表空间中也包含表的表数据和索引数据。</p>
<h4 id="系统表空间的问题"><a href="#系统表空间的问题" class="headerlink" title="系统表空间的问题"></a>系统表空间的问题</h4><p>在 MySQL 5.6.7 之前，默认设置是将所有<code>InnoDB</code>表和索引保留 在系统表空间内，这通常会导致该文件变得非常大。因为系统表空间永远不会缩小，所以如果先加载然后删除大量临时数据，则可能会出现存储问题。</p>
<p>在 MySQL 5.7 中，默认设置为 <strong>独立表空间</strong>模式，其中每个表及其相关索引存储在单独的 <strong>.ibd 文件中</strong>。此默认设置使使用**<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_barracuda">Barracuda</a><strong>文件格式的<code>InnoDB</code>功能更容易使用，例如表</strong>压缩<strong>，</strong>页外列的**有效存储以及大索引键前缀（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_large_prefix">innodb_large_prefix</a>）。</p>
<p>将所有表数据保留在系统表空间或单独的 <code>.ibd</code>文件中通常会对存储管理产生影响。</p>
<p><code>InnoDB</code>在 MySQL 5.7.6 中引入了<strong>通用表空间</strong>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-6">6]</a>，这些表空间也由<code>.ibd</code>文件表示 。通用表空间是使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/create-tablespace.html">CREATE TABLESPACE</a>语法创建的共享表空间。它们可以在 MySQL 数据目录之外创建，能够容纳多个表，并支持所有行格式的表。</p>
<h3 id="3-5-2、独立表空间"><a href="#3-5-2、独立表空间" class="headerlink" title="3.5.2、独立表空间"></a><em>3.5.2、独立表空间</em></h3><p>MySQL 5.7 中，配置参数：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_per_table">innodb_file_per_table</a>，默认处于启用状态，这是一个重要的配置选项，会影响<code>InnoDB</code>文件存储，功能的可用性和 I/O 特性等。</p>
<p>启用之后，每个表的数据和索引是存放在单独的.ibd 文件中的，而不是在系统表空间的共享 ibdata 文件中。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>您可以更加灵活的选择<code>数据压缩</code>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-4">4]</a>的行格式，如：</li>
<li>默认情况下（innodb_page_size=16K），<code>前缀索引</code><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/[%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%B8%80%E7%A7%8D%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.">^5</a>最多包含 768 个字节。如果开启 innodb_large_prefix，且 Innodb 表的存储行格式为 DYNAMIC 或 COMPRESSED，则前缀索引最多可包含 3072 个字节，前缀索引也同样适用；</li>
<li><code>TRUNCATE TABLE</code>执行的更快，并且回收的空间不会继续保留，而是让操作系统使用；</li>
<li>可以在单独的存储设备上创建每表文件表空间数据文件，以进行 I / O 优化，空间管理或备份。请参见 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-table-external.html">14.6.1.2 Creating Tables Externally</a>；</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>独立表空间中的未使用空间只能由同一个表使用，如果管理不当，会造成空间浪费；</li>
<li>多个表需要刷盘，只能执行多次 fsync，无法合并多个表的写操作，这可能会导致更多的 fsync 操作总数；</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html">mysqld</a>必须为每个表文件空间保留一个打开的文件句柄，如果表数量多，可能会影响性能；</li>
<li>每个表都需要自己的数据文件，需要更多的文件描述符；</li>
</ul>
<blockquote>
<p>即使启用了 innodb_file_per_table 参数，每张表空间存放的只是数据、索引和插入缓存 Bitmap 页，其他数据如回滚信息、插入缓冲索引页、系统事务信息、二次写缓冲等还是存放在原来的共享表空间中。</p>
</blockquote>
<h3 id="3-5-3、通用表空间"><a href="#3-5-3、通用表空间" class="headerlink" title="3.5.3、通用表空间"></a><em>3.5.3、通用表空间</em></h3><p>通用表空间使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/create-tablespace.html">CREATE TABLESPACE</a>语法创建。</p>
<p>类似于系统表空间，通用表空间是共享表空间，可以存储多个表的数据。</p>
<p>通用表空间比独立表空间具有潜在的内存优势，服务器在表空间的生存期内将表空间元数据保留在内存中。一个通用表空间通常可以存放多个表数据，消耗更少的表空间元数据内存。</p>
<p>数据文件可以放置在 MySQL 数据目录或独立于 MySQL 数据目录。</p>
<h3 id="3-5-4、undo-表空间"><a href="#3-5-4、undo-表空间" class="headerlink" title="3.5.4、undo 表空间"></a><em>3.5.4、undo 表空间</em></h3><p>undo 表空间包含 undo log。</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_rollback_segments">innodb_rollback_segments</a>变量定义分配给每个撤消表空间的回滚段的数量。</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log">undo log</a>可以存储在一个或多个<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_tablespace">undo表空间</a>中，而不是<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace">系统表空间中</a>。</p>
<p>在默认配置中，撤消日志位于<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace">系统表空间</a>中。SSD 存储更适合 undo log 的 I/O 模式，为此，可以把 undo log 存放在有别于系统表空间的 ssd 硬盘中。</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces">innodb_undo_tablespaces</a> 配置选项控制 undo 表空间的数量。</p>
<h3 id="3-5-5、临时表空间"><a href="#3-5-5、临时表空间" class="headerlink" title="3.5.5、临时表空间"></a><em>3.5.5、临时表空间</em></h3><p>由用户创建的非压缩临时表和磁盘内部临时表是在共享临时表空间中创建的。</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_temp_data_file_path">innodb_temp_data_file_path</a> 配置选项指定零时表空间文件的路径，如果未指定，则默认在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a>目录中创建一个略大于 12MB 的自动扩展数据文件<code>ibtmp1</code> 。</p>
<p>使用<code>ROW_FORMAT=COMPRESSED</code>属性创建的压缩临时表，是在独立表空间中的临时文件目录中创建的 。</p>
<p>服务启动的时候创建临时表空间，关闭的时候销毁临时表空间。如果临时表空间创建失败，则意味着服务启动失败。</p>
<h2 id="3-6、InnoDB-底层逻辑存储结构"><a href="#3-6、InnoDB-底层逻辑存储结构" class="headerlink" title="3.6、InnoDB 底层逻辑存储结构"></a>3.6、InnoDB 底层逻辑存储结构</h2><p>在介绍索引之前，我们有必要了解一下 InnoDB 底层的逻辑存储结构，因为索引是基于这个底层逻辑存储结构创建的。截止到目前，我们所展示的都仅仅是物理磁盘中的逻辑视图，接下来我们就来看看底层的视图。</p>
<h3 id="3-6-1、ibd-文件组织结构"><a href="#3-6-1、ibd-文件组织结构" class="headerlink" title="3.6.1、ibd 文件组织结构"></a><em>3.6.1、ibd 文件组织结构</em></h3><p>现在<strong>我们打开一个表空间 ibd 文件，看看里面都是如何组织数据的？</strong></p>
<p>如下图，表空间由段(segment)、区(extent)、页(page)组成。</p>
<p>InnoDB 最小的存储单位是页，默认每个页大小是 16k。</p>
<p>而 InnoDB 存储引擎是面向行的(row-oriented)，数据按行进行存放，每个页规定最多允许存放的行数=16k/2 - 200，即 7992 行。</p>
<p><img src="https://static001.geekbang.org/infoq/71/715646b8db39a9537925e985c5140c70.png" alt="img"></p>
<p>段：如数据段、索引段、回滚段等。<strong>InnoDB 存储引擎是 B+树索引组织的</strong>，所以数据即索引，索引即数据。B+树的叶子节点存储的都是数据段的数据。</p>
<h3 id="3-6-2、数据页结构-13"><a href="#3-6-2、数据页结构-13" class="headerlink" title="3.6.2、数据页结构[13]"></a><em>3.6.2、数据页结构[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-13">13]</a></em></h3><p><img src="https://static001.geekbang.org/infoq/40/40b49988fae5165d7c3bda8b97bd5811.png" alt="img"></p>
<p>关于 Infimun 和 Supremum：首次创建索引时，InnoDB 会在根页面中自动设置一个最小记录和一个最高记录，并且永远不会删除它们。最低记录和最高记录可以视为索引页开销的一部分。最初，它们都存在于根页面上，但是随着索引的增长，最低记录将存在于第一或最低叶子页上，最高记录将出现在最后或最大关键字页上。</p>
<p><img src="https://static001.geekbang.org/infoq/aa/aa9baf9a9b646faa5e2cea311d7f6d59.png" alt="img"></p>
<h3 id="3-6-3、行记录结构描述-14"><a href="#3-6-3、行记录结构描述-14" class="headerlink" title="3.6.3、行记录结构描述[14]"></a><em>3.6.3、行记录结构描述[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-14">14]</a></em></h3><p>先来讲讲 Compact 行记录格式，Compact 是 MySQL5.0 引入的，设计目标是高效的存储数据，让一个页能够存放更多的数据，从而实现更快的 B+树查找。</p>
<p><img src="https://static001.geekbang.org/infoq/c0/c08ba3394d4b0d0ba15091f832c6dd9b.png" alt="img"></p>
<p><strong>记录头用于将连续的记录链接在一起，并用于行级锁定。</strong></p>
<p>每行数据除了用户定义的列外，还有两个隐藏列：</p>
<ul>
<li>6 个字节的事务 ID 列；</li>
<li>7 个字节的回滚指针列；</li>
<li>如果 InnoDB 没有指定主键，还会增加一个 6 个字节的 rowid 列；</li>
</ul>
<p>而记录头信息包[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-12">12]</a>含如下内容：</p>
<p><img src="https://static001.geekbang.org/infoq/ae/ae2ccab542372899af15f7bd96f075ce.png" alt="img"></p>
<p><img src="https://static001.geekbang.org/infoq/54/54e61e95192ef5db3222fd2250a8b41b.png" alt="img"></p>
<blockquote>
<p>更详细的页结构参考官网：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/internals/en/innodb-page-structure.html">22.2 InnoDB Page Structure</a></p>
<p>更详细的行结构参考官网：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/internals/en/innodb-record-structure.html">22.1 InnoDB Record Structure</a></p>
<p>更详细的行格式参考官网：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html">14.11 InnoDB Row Formats</a></p>
</blockquote>
<p>根据以上格式，可以得出数据页内的记录组织方式：</p>
<p><img src="https://static001.geekbang.org/infoq/e9/e9478f2b6b6437599ce100535edc2a73.png" alt="img"></p>
<h4 id="3-6-3-1、MySQL-中-varchar-最大长度是多少"><a href="#3-6-3-1、MySQL-中-varchar-最大长度是多少" class="headerlink" title="3.6.3.1、MySQL 中 varchar 最大长度是多少"></a>3.6.3.1、MySQL 中 varchar 最大长度是多少</h4><p>上面表格描述我们知道，一个字段最长限制是 65535 个字节，这是存储长度的限制。</p>
<p>而 MySQL 中对存储是有限制的，具体参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html">8.4.7 Limits on Table Column Count and Row Size</a></p>
<ul>
<li>MySQL 对每个表有 4096 列的硬限制，但是对于给定的表，有效最大值可能会更少；</li>
<li><strong>MySQL 表的每行行最大限制为 65,535 字节</strong>，这是逻辑的限制；实际存储的时候，表的物理最大行大小略小于页面的一半。如果一行的长度少于一页的一半，则所有行都将存储在本地页面内。如果它超过一页的一半，那么将选择可变长度列用于外部页外存储，直到该行大小控制在半页之内为止。</li>
</ul>
<p>而实际能够存储的字符是跟编码有关的。</p>
<blockquote>
<p>背景知识：</p>
<ul>
<li>MySQL 4.0 版本以下，varchar(10)，代表 10 个<strong>字节</strong>，如果存放 UTF8 汉字，那么只能存 3 个（每个汉字 3 字节）；</li>
<li>MySQL 5.0 版本以上，varchar(10)，指的是 10 个<strong>字符</strong>，无论存放的是数字、字母还是 UTF8 汉字（每个汉字 3 字节），都可以存放 10 个，最大大小是 65532 <strong>字节</strong>；</li>
</ul>
<p><strong>因此，Mysql5 根据编码不同,存储大小也不同。</strong></p>
</blockquote>
<p>那么假设我们使用的是 utf8 编码，那么每个字符最多占用 3 个字节，也就是最多定义 varchar(21845)个字符，如果是 ascii 编码，一个字符相当于一个字节，最多定义 varchar(65535)个字符，下面我们验证下。</p>
<p>我们尝试创建一个这样的字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;t10&#96; ( &#96;id&#96; int(11) NOT NULL,                  &#96;a&#96; int(11) NOT NULL,                  PRIMARY KEY (&#96;id&#96;)                 ) ENGINE&#x3D;InnoDB CHARSET&#x3D;ascii ROW_FORMAT&#x3D;Compact;</span><br><span class="line"></span><br><span class="line">alter table t10 add &#96;str&#96; varchar(21845) DEFAULT NULL;</span><br><span class="line">alter table t10 add &#96;str&#96; varchar(65535) DEFAULT NULL;</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>发现提示这个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t10 add &#96;str&#96; varchar(65535) DEFAULT NULL;ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>原因是按照以上的行格式介绍，<code>变长字段长度列表</code>记录也需要占用空间，占用 2 个字节，另外这里是允许为空字段，在 8 位之内，所以 NULL 标志位占用 1 个字节，所以我们总共可以存储的字符数是：</p>
<blockquote>
<p>65535 - 2 - 2 - 4 - 4=65534</p>
<p>其中 -2 个字节表示变长字段列表，-1 表示 NULL 标志位，两个-4 表示两个 int 类型字段占用大小</p>
</blockquote>
<p>所以实际上能够容纳的 varchar 大小为：65524，我们验证下：</p>
<p><img src="https://static001.geekbang.org/infoq/f2/f231c40f96ed9b8c3538b844674421f3.png" alt="img"></p>
<h4 id="3-6-3-2、行记录超过页大小如何存储"><a href="#3-6-3-2、行记录超过页大小如何存储" class="headerlink" title="3.6.3.2、行记录超过页大小如何存储"></a>3.6.3.2、行记录超过页大小如何存储</h4><p>MySQL 表的内部表示具有 65,535 字节的最大行大小限制。<code>InnoDB</code> 对于 4KB，8KB，16KB 和 32KB <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size">innodb_page_size</a> 设置，表的最大行大小（适用于本地存储在数据库页面内的数据）略小于页面的一半 。如果包含 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_variable_length_type">可变长度列</a>的<code>InnoDB</code> 行超过最大行大小，那么将选择可变长度列用于外部页外存储。</p>
<p>可变长度列由于太长而无法容纳在 B 树页面上，这个时候会把可变长度列存储在单独分配的磁盘页面上，这些页面称为<code>溢出页面</code>，这些列称为<code>页外列</code>。页外列的值存储在由溢出页面构成的<code>单链接列表</code>中。</p>
<p><code>InnoDB</code>存储引擎支持四种行格式：<code>REDUNDANT</code>，<code>COMPACT</code>， <code>DYNAMIC</code>，和<code>COMPRESSED</code>。不同的行格式，对溢出的阈值和处理方式有所区别，详细参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html#innodb-row-format-compact">14.11 InnoDB Row Formats</a>。</p>
<p><strong>COMPACT 行格式处理方式</strong></p>
<p>使用<code>COMPACT</code>行格式的表将前 768 个字节的变长列值（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/char.html">VARCHAR</a>， <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html">VARBINARY</a>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/blob.html">BLOB</a>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/blob.html">TEXT</a>类型）存储在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_b_tree">B树</a>节点内的索引记录中，其余的存储在溢出页上。</p>
<p>如果列的值等于或小于 <strong>768 个字节</strong>，则不使用溢出页，因此可以节省一些 I / O。</p>
<p>如果查过了 768 个字节，那么会按照如下方式进行存储：</p>
<p><img src="https://static001.geekbang.org/infoq/41/4165d33aec8fe67b369f5f3b1f26f12d.png" alt="img"></p>
<p><strong>DYNAMIC 行格式处理方式</strong></p>
<p><code>DYNAMIC</code>行格式提供与<code>COMPACT</code>行格式相同的存储特性，但改进了超长可变长度列的存储能力和支持大索引键前缀。</p>
<p><code>InnoDB</code> 可以完全在页外存储过长的可变长度列值（针对 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/char.html">VARCHAR</a>， <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html">VARBINARY</a>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/blob.html">BLOB</a>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/blob.html">TEXT</a>类型），而聚集索引记录仅包含指向溢出页的 20 字节指针。大于或等于 768 字节的固定长度字段被编码为可变长度字段。</p>
<p><img src="https://static001.geekbang.org/infoq/5c/5c81c066e014bc239a8f06058c04fac7.png" alt="img"></p>
<blockquote>
<p><strong>表中大字段引发的问题</strong></p>
<p>如果一个表中有过多的可变长度大字段，导致一行记录太长，而整个时候使用的是 COMPACT 行格式，那么就可能会插入数据报错。</p>
<p>如，页面大小事 16k，根据前面描述我们知道，MySQL 限制一页最少要存储两行数据，如果很多可变长度大字段，在使用 COMPACT 的情况下，仍然会把大字段的前面 768 个字节存在索引页中，可以算出最多支持的大字段：<code>1024 * 16 / 2 / 768 = 10.67</code>，那么超过 10 个可变长度大字段就会插入失败了。</p>
<p>这个时候可以把 row format 改为：DYNAMIC。</p>
</blockquote>
<h2 id="3-7、索引"><a href="#3-7、索引" class="headerlink" title="3.7、索引"></a>3.7、索引</h2><p>前面我们了解了 InnoDB 底层的存储结构，即：以 B+树的方式组织数据页。另外了解了数据页中的数据行的存储方式。</p>
<p>而构建 B+树索引的时候必须要选定一个或者多个字段作为索引的值，如果索引选择的是主键，那么我们就称为聚集索引，否则就是二级索引。</p>
<blockquote>
<p>为什么 MySQL 使用 B+树？</p>
<ul>
<li>哈希表虽然可以提供 O(1)的单行数据操作性能，但却不能很好的支持排序和范围查找，会导致全表扫描；</li>
<li>B 树可以再非叶子节点存储数据，但是这可能会导致查询连续数据的时候增加更多的 I/O 操作；</li>
<li>而 B+树数据都存放在叶子节点，叶子节点通过指针相互连接，可以减少顺序遍历时产生的额外随机 I/O</li>
</ul>
<p>更新详细解释: <a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-mysql-b-plus-tree/">为什么 MySQL 使用 B+ 树</a>[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-29">29]</a></p>
</blockquote>
<h3 id="3-7-1、聚集索引"><a href="#3-7-1、聚集索引" class="headerlink" title="3.7.1、聚集索引"></a><em>3.7.1、聚集索引</em></h3><p>了解到上面的底层逻辑存储结构之后，我们进一步来看看 InnoDB 是怎么通过 B+树来组织存储数据的。</p>
<p>首先来介绍下聚集索引。</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>主键索引的 InnoDB 术语。</p>
<p>下面我们创建一张测试表，并插入数据，来构造一颗 B+树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t20 (    id int NOT NULL,    a int NOT NULL,    b int,    c int,    PRIMARY KEY (&#96;id&#96;)  ) ENGINE&#x3D;InnoDB;      insert into t20 values(20, 1, 2, 1); insert into t20 values(40, 1, 2, 5); insert into t20 values(30, 3, 2, 4); insert into t20 values(50, 3, 6, 2); insert into t20 values(10, 1, 1, 1);</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>可以看到，虽然我们是 id 乱序插入的，但是插入之后查出来的确是排序好的：</p>
<p><img src="https://static001.geekbang.org/infoq/71/717bfcf305df41c88d7e65680f899952.png" alt="img"></p>
<p>这个排序就是 B+索引树构建的。</p>
<p>我们可以通过这个<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">在线的动态演示工具</a>来看看 B+树的构造过程，最终结果如下：</p>
<p><img src="https://static001.geekbang.org/infoq/05/05e74c9848b9ed6bf1b399f0004ec794.png" alt="img"></p>
<blockquote>
<p>实际存放在数据库中的模型因页面大小不一样而有所不同，这里为了简化模型，我们按照 B+树的通用模型来解释数据的存储结构。</p>
</blockquote>
<p>类似的，我们的数据也是这种组织形式的，该 B+树中，我们以主键为索引进行构建，并且把完整的记录存到对应的页下面：</p>
<p><img src="https://static001.geekbang.org/infoq/cf/cfbf40298bf650ae945ed4b1efbf2869.png" alt="img"></p>
<p>其中蓝色的是索引页，橙色的是数据页。</p>
<p>每个页的大小默认为 16k，如果插入新的数据行，这个时候就要申请新的数据页了，然后挪动部分数据过去，重新调整 B+树，这个过程称为<code>页分裂</code>，这个过程会影响性能。</p>
<p>相反的，如果<code>InnoDB</code>索引页的填充因子下降到之下<code>MERGE_THRESHOLD</code>，默认情况下为 50％（如果未指定），则<code>InnoDB</code>尝试收缩索引树以释放页面。</p>
<p>自增主键的插入是递增顺序插入的，每次添加记录都是追加的，不涉及到记录的挪动，不会触发叶子节点的分裂，而一般业务字段做主键，往往都不是有序插入的，写成本比较高，所以我们<strong>更倾向于使用自增字段作为主键。</strong></p>
<h4 id="聚集索引注意事项"><a href="#聚集索引注意事项" class="headerlink" title="聚集索引注意事项"></a>聚集索引注意事项</h4><ul>
<li>当在表上面定义了<code>PRIMARY KEY</code>之后，InnoDB 会把它作为聚集索引。为此，为你的每个表定义一个<code>PRIMARY KEY</code>。如果没有唯一并且非空的字段或者一组列，那么请添加一个自增列；</li>
<li>如果您没有为表定义<code>PRIMARY KEY</code>，则 MySQL 会找到第一个不带 null 值的 UNIQUE 索引，并其用作聚集索引；</li>
<li>如果表没有<code>PRIMARY KEY</code>或没有合适的<code>UNIQUE</code>索引，则<code>InnoDB</code> 内部会生成一个隐藏的聚集索引<code>GEN_CLUST_INDEX</code>，作为行 ID，行 ID 是一个 6 字节的字段，随着数据的插入而自增。</li>
</ul>
<h4 id="聚集索引查找"><a href="#聚集索引查找" class="headerlink" title="聚集索引查找"></a>聚集索引查找</h4><p>根据索引进行查找 id=50 的记录，如下图，沿着 B+树一直往下寻找，最终找到第四页<strong>，然后把该页加载到 buffer pool 中，在缓存中遍历对比查找</strong>，由于里面的行记录是顺序组织的，所以很快就可以定位到记录了。</p>
<p><img src="https://static001.geekbang.org/infoq/cf/cf012b0a6aaba79f340aa860a83b9b16.png" alt="img"></p>
<h3 id="3-7-2、辅助索引"><a href="#3-7-2、辅助索引" class="headerlink" title="3.7.2、辅助索引"></a><em>3.7.2、辅助索引</em></h3><p>除了聚集索引之外的所有索引都称为辅助索引(二级索引)。在 InnoDB 中，辅助索引中每个记录都包含该行的主键列以及为辅助索引指定的列。</p>
<p>在辅助索引中查找到记录，可以得到记录的主键索引 ID，然后可以通过这个主键索引 ID 去聚集索引中搜索具体的记录，这个过程称为<strong>回表</strong>操作。</p>
<p><strong>如果主键较长，则辅助索引将使用更多空间，因此具有短的主键是有利的。</strong></p>
<p>下面我们给刚刚的表添加一个组合联合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 添加多一个字段alter table t20 add column d varchar(20) not null default &#39;&#39;;-- 添加一个联合索引4alter table t20 add index idx_abc(a, b, c);</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>添加之后组合索引 B+树如下，其中索引 key 为 abc 三个字段的组合，索引存储的记录为主键 ID：</p>
<p><img src="https://static001.geekbang.org/infoq/58/586102e0ad6266ff6470f8018bffb24a.png" alt="img"></p>
<h4 id="覆盖索引-Using-index"><a href="#覆盖索引-Using-index" class="headerlink" title="覆盖索引(Using index)"></a>覆盖索引(Using index)</h4><p>InnoDB 存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要回表去查询聚集索引中的记录，从而减少大量的 IO 操作。下面的查询既是用到了覆盖索引 idx_abc：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a, b from t20 where a &gt; 2;</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>执行结果如下：</p>
<p><img src="https://static001.geekbang.org/infoq/43/43dff938c76dac4bfb04d29cde06708f.png" alt="img"></p>
<p>可以发现，Extra 这一列提示 Using index，使用到了覆盖索引，扫描的行数为 2。<strong>注意：这里的扫描行数指的是 MySQL 执行器从引擎取到两条记录，引擎内部可能会遍历到多条记录进行条件比较。</strong></p>
<h4 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h4><p>由于 InnoDB 索引式 B+树构建的，因此可以利用索引的“最左前缀”来定位记录。</p>
<p>也就是说，不仅仅是用到索引的全部定义字段会走索引，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 n 个字段。</p>
<h4 id="索引条件下推-Using-index-condition"><a href="#索引条件下推-Using-index-condition" class="headerlink" title="索引条件下推(Using index condition)"></a>索引条件下推(Using index condition)</h4><p>索引条件下推 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html">Index Condition Pushdown</a> (ICP)，是针对 MySQL 使用索引从表中检索行的情况的一种优化。</p>
<p><strong>为什么叫下推呢，就是在满足要求的情况下，把索引的条件丢给存储引擎去判断，而不是把完整的记录传回 MySQL Server 层去判断。</strong></p>
<p>ICP 支持<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_range">range</a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_ref">ref</a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_eq_ref">eq_ref</a>, 和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_ref_or_null">ref_or_null</a>类型的查找，支持 MyISAM 和 InnoDB 存储引擎。</p>
<p>不能将引用子查询的条件下推，触发条件不能下推。详细规则参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html">Index Condition Pushdown</a></p>
<p>如果不使用 ICP，则存储引擎将遍历索引以在聚集索引中定位行，并将结果返回给 MySQL Server 层，MySQL Server 层继续根据<code>WHERE</code>条件进行筛选行。</p>
<p>启用 ICP 后，如果<code>WHERE</code>可以仅使用索引中的列来评估部分条件，则 MySQL Server 层会将这部分条件压入<code>WHERE</code>条件下降到存储引擎。然后，存储引擎通过使用索引条目来判断索引条件，在满足条件的情况下，才回表去查找记录返回给 MySQL Server 层。</p>
<p><strong>ICP 的目标是减少回表扫描的行数，从而减少 I / O 操作。对于<code>InnoDB</code>表，ICP 仅用于二级索引。</strong></p>
<p>使用索引下推的时候，执行计划中的 Extra 会提示：<code>Using index condition</code>，而不是<code>Using index</code>，因为必须回表查询整行数据。<code>Using index</code>代表使用到了覆盖索引。</p>
<h2 id="3-8、InnoDB-Data-Directory"><a href="#3-8、InnoDB-Data-Directory" class="headerlink" title="3.8、InnoDB Data Directory"></a>3.8、InnoDB Data Directory</h2><p>InnoDB 数据字典(Data Directory)存放于系统表空间中，主要包含元数据，用于追踪表、索引、表字段等信息。由于历史的原因，InnoDB 数据字典中的元数据与<code>.frm</code>文件中的元数据重复了。</p>
<h2 id="3-9、Doublewrite-Buffer"><a href="#3-9、Doublewrite-Buffer" class="headerlink" title="3.9、Doublewrite Buffer"></a>3.9、Doublewrite Buffer</h2><p>双写缓冲区(Doublewrite Buffer)是一个存储区，是 InnoDB 在 tablespace 上的 128 个页（2 个区），大小是 2MB[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-7">7]</a>。</p>
<blockquote>
<p>版本区别：在 MySQL 8.0.20 之前，doublewrite 缓冲区存储区位于<code>InnoDB</code>系统表空间中。从 MySQL 8.0.20 开始，doublewrite 缓冲区存储区位于 doublewrite 文件中。</p>
<p>本文基于 MySQL 5.7 编写。</p>
</blockquote>
<p>操作系统写文件是以 4KB 为单位的，那么每写一个 InnoDB 的 page 到磁盘上，操作系统需要写 4 个块。如果写入 4 个块的过程中出现系统崩溃，那么会导致 16K 的数据只有一部分写是成功的，这种情况下就是<code>partial page write</code>（部分页写入）问题。</p>
<p>InnoDB 这个时候是没法通过 redo log 来恢复的，因为这个时候页面的<code>Fil Trailer</code>（Fil Trailer 主要存放<code>FIL_PAGE_END_LSN</code>，主要包含页面校验和以及最后的事务）中的数据是有问题的。</p>
<p>为此，每当 InnoDB 将页面写入到数据文件中的适当位置之前，都会首先将其写入双写缓冲区。只有将缓冲区安全地刷新到磁盘后，InnoDB 才会将页面写入最终的数据文件。</p>
<p><img src="https://static001.geekbang.org/infoq/98/980bdeb88943b4d724c42d633a075d60.png" alt="img"></p>
<p>如果在页面写入过程中发生操作系统或者 mysqld 进程崩溃，则 InnoDB 可以在崩溃恢复期间从双写缓冲区中找到页面的完好副本用于恢复。恢复时，InnoDB 扫描双写缓冲区，并为缓冲区中的每个有效页面检查数据文件中的页面是否完整。</p>
<p>如果系统表空间文件（“ ibdata 文件 ”）位于支持原子写的 Fusion-io 设备上，则自动禁用双写缓冲，并且将 Fusion-io 原子写用于所有数据文件。</p>
<h2 id="3-10、Redo-Log"><a href="#3-10、Redo-Log" class="headerlink" title="3.10、Redo Log"></a>3.10、Redo Log</h2><p>重做日志(Redo Log)主要适用于数据库的崩溃恢复，用于实现数据的完整性。</p>
<p>重做日志由两部分组成：</p>
<ul>
<li>重做日志缓冲区 Log Buffer；</li>
<li>重做日志文件，重做日志文件在磁盘上由两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的物理文件表示。</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/f6/f6ce50890fb0ea53c20b78b461c799b2.png" alt="img"></p>
<p><strong>为了实现数据完整性，在脏页刷新到磁盘之前，必须先把重做日志写入到磁盘。除了数据页，聚集索引、辅助索引以及 Undo Log 都需要记录重做日志。</strong></p>
<h3 id="3-10-1、Redo-Log-在事务中的写入时机"><a href="#3-10-1、Redo-Log-在事务中的写入时机" class="headerlink" title="3.10.1、Redo Log 在事务中的写入时机"></a><em>3.10.1、Redo Log 在事务中的写入时机</em></h3><p>在事务中，除了写 Redo log，还需要写 binlog，为此，我们先来简单介绍下 binlog。</p>
<h4 id="3-10-1-1、binlog"><a href="#3-10-1-1、binlog" class="headerlink" title="3.10.1.1、binlog"></a>3.10.1.1、binlog</h4><p>全写：Binary Log，二进制 log。二进制日志是一组日志文件。其中包含有关对 MySQL 服务器实例进行的数据修改的信息。</p>
<p><strong>Redo Log 是 InnoDB 引擎特有的，而 binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</strong></p>
<p><strong>Redo Log 的文件是循环写的，空间会用完，binlog 日志是追加写的，不会覆盖以前的日志。</strong></p>
<p><strong>binlog 主要的目的：</strong></p>
<ul>
<li>主从同步，主服务器将二进制日志中包含的事件发送到从服务器，从服务器执行这些事件，以保持和主服务器相同的数据更改；</li>
<li>某些数据恢复操作需要使用二进制日志，还原到某一个备份点。</li>
</ul>
<p><strong>binlog 主要是用于主从同步和数据恢复，Redo Log 主要是用于实现事务数据的完整性，让 InnoDB 具有不会丢失数据的能力，又称为 crash-safe。</strong></p>
<p><strong>binlog 日志的两种记录形式：</strong></p>
<ul>
<li>基于 SQL 的日志记录：事件包含产生数据更改(插入，新增，删除)的 SQL 语句；</li>
<li>基于行的日志记录：时间描述对单个行的更改。</li>
</ul>
<p>混合日志记录默认情况下使用基于语句的日志记录，但根据需要自动切换到基于行的日志记录。</p>
<h4 id="3-10-1-2、Redo-Log-在事务中的写入时机"><a href="#3-10-1-2、Redo-Log-在事务中的写入时机" class="headerlink" title="3.10.1.2、Redo Log 在事务中的写入时机"></a>3.10.1.2、Redo Log 在事务中的写入时机</h4><p>简单的介绍完 binlog，我们再来看看 Redo Log 的写入流程。</p>
<p>假设我们这里执行一条 sql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t20 set a&#x3D;10 where id&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>执行流程如下：</p>
<p><img src="https://static001.geekbang.org/infoq/f8/f8a8e4f92d00bf7f8cdb405dfadf8a92.png" alt="img"></p>
<h3 id="3-10-2、如何保证数据不丢失"><a href="#3-10-2、如何保证数据不丢失" class="headerlink" title="3.10.2、如何保证数据不丢失"></a><em>3.10.2、如何保证数据不丢失</em></h3><p>前面我们介绍<code>Log Buffer</code>的时候，提到过，为了保证数据不丢失，我们需要执行以下操作：</p>
<ul>
<li>如果启用了 binlog，则设置：sync_binlog=1;</li>
<li>innodb_flush_log_at_trx_commit=1;</li>
</ul>
<blockquote>
<ul>
<li>sync_binlog=0：表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1：表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) ：表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
</blockquote>
<p>这两个的作用相当于在上面的流程最后一步，提交事务接口返回 Server 层之前，把 binlog cache 和 log buffer 都 fsync 到磁盘中了，这样就保证了数据的落盘，不会丢失，即使奔溃了，也可以通过 binlog 和 redo log 恢复数据相关流程如下：</p>
<p><img src="https://static001.geekbang.org/infoq/0e/0e57c3e6aa3c30ea5c9aaca83e8ed3e3.png" alt="img"></p>
<p>在磁盘和内存中的处理流程如下面编号所示：</p>
<p><img src="https://static001.geekbang.org/infoq/b7/b7d1c7c95da3ad2fbb6a07706bdb1f3e.png" alt="img"></p>
<p><strong>其中第四步 log buffer 持久化到磁盘的时机为：</strong></p>
<ul>
<li>log buffer 占用的空间即将达到<code>innodb_log_buffer_size</code>一半的时候，后台线程主动写盘；</li>
<li>InnoDB 后台有个线程，每隔 1 秒会把 log buffer 刷到磁盘；</li>
<li>由于 log buffer 是所有线程共享的，当其他事务线程提交时也会导致已写入 log buffer 但还未提交的事务的 redo log 一起刷新到磁盘</li>
</ul>
<p><strong>其中第五步：脏页刷新到磁盘的时机为：</strong></p>
<ul>
<li>系统内存不足，需要淘汰脏页的时候，要把脏页同步回磁盘；</li>
<li>MySQL 空闲的时候；</li>
<li>MySQL 正常关闭的时候，会把脏页 flush 到磁盘。</li>
</ul>
<blockquote>
<p>参数<code>innodb_max_dirty_pages_pct</code>是脏页比例上限，默认值是 75%。</p>
</blockquote>
<p><strong>为什么第二步 redo log prepare 状态也要写磁盘？</strong></p>
<p>因为这里先写了，才能确保在把 binlog 写到磁盘后崩溃，能够恢复数据：如果判断到 redo log 是 prepare 状态，那么查看是否存 XID 对应的 binlog，如果存在，则表示事务成功提交，需要用 prepare 状态的 redo log 进行恢复。</p>
<p><strong>这样即使崩溃了，也可以通过 redo log 来进行恢复了，恢复流程如下：</strong></p>
<p>Redo Log 是循环写的，如下图:</p>
<ul>
<li>writepos 记录了当前写的位置，一边写位置一边往前推进，当 writepos 与 checkpoint 重叠的时候就表示 logfile 写满了，绿色部分表示是空闲的空间，红色部分是写了 redo log 的空间；</li>
<li>checkpoint 处标识了当前的<code>LSN</code>，每当系统崩溃重启，都会从当前 checkpoint 这个位置执行重做日志，根据重做日志逐个确认数据页是否没问题，有问题就通过 redo log 进行修复。</li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/23/23f88bb152b4f0adac684f89e6b587be.png" alt="img"></p>
<blockquote>
<p>LSN Log Sequence Number 的缩写。代表日志序列号。在 InnoDB 中，LSN 占用 8 个字节，单调递增，LSN 的含义：</p>
<ul>
<li>重做日志写入的总量；</li>
<li>checkpoint 的位置；</li>
<li>页的版本；</li>
</ul>
<p>除了重做日志中有 LSN，每个页的头部也是有存储了该页的 LSN，我们前面介绍页面格式的时候有介绍过。</p>
<p>在页中 LSN 表示该页最后刷新时 LSN 的大小。[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-8">8]</a></p>
</blockquote>
<h2 id="3-11、Undo-Logs"><a href="#3-11、Undo-Logs" class="headerlink" title="3.11、Undo Logs"></a>3.11、Undo Logs</h2><p>上面说的 <strong>redo log 记录了事务的行为，可以通过其对页进行重做操作，但是食物有时候需要进行回滚，这时候就需要 undo log 了</strong>。[<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/ed531f74ecfd44eacb1a98258#footnote-15">15]</a></p>
<p><strong>关于 Undo Log 的存储：</strong>InnoDB 中有回滚段(rollback segment)，每个回滚段记录 1024 个 undo log segment，在每个 undo log segment 段中进行申请 undo 页。系统表空间偏移量为 5 的页记录了所有的 rollback segment header 所在的页。</p>
<p><img src="https://static001.geekbang.org/infoq/04/04d37a15176edac0ff0b6931999131e1.png" alt="img"></p>
<h3 id="3-11-1、undo-log-的格式"><a href="#3-11-1、undo-log-的格式" class="headerlink" title="3.11.1、undo log 的格式"></a><em>3.11.1、undo log 的格式</em></h3><p>根据行为不同分为两种：</p>
<p><strong>insert undo log</strong></p>
<p><code>insert undo log</code>：只对事务本身可见，所以 insert undo log 在事务提交后可直接删除，无需执行 purge 操作；</p>
<p>insert undo log 主要记录了：</p>
<p><img src="https://static001.geekbang.org/infoq/7c/7ced3b4db0ff7f5bd7d415c187c09aa6.png" alt="img"></p>
<p>假设在事务 1001 中，执行以下 sql，t20 的 table_id 为 10：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t20(id, a, b, c, d) values(12, 2, 3, 1, &quot;init&quot;)</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>那么对应会生成一条 undo log：</p>
<p><img src="https://static001.geekbang.org/infoq/f1/f1b622bf440153b664e1bcae91e3c101.png" alt="img"></p>
<p><strong>update undo log</strong></p>
<p><code>update undo log</code>：执行 update 或者 delete 会产生 undo log，会影响已存在的记录，为了实现 MVCC(后边介绍)，update undo log 不能再事务提交时立刻删除，<strong>需要将事务提交时放入到 history list 上，等待 purge 线程进行最后的删除操作。</strong></p>
<p>update undo log 主要记录了：</p>
<p><img src="https://static001.geekbang.org/infoq/23/239309e16eb1f1f98b74150a4439bb7f.png" alt="img"></p>
<p>假设在事务 1002 中，执行以下 sql，t20 的 table_id 为 10：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t20 set d&#x3D;&quot;update1&quot; where id&#x3D;60;</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>那么对应会生成一条 undo log：</p>
<p><img src="https://static001.geekbang.org/infoq/f8/f8d1653e0cc5747edacdd729eb05f2d1.png" alt="img"></p>
<p>如上图，<strong>每回退应用一个 undo log，就回退一个版本，这就是 MVCC(Multi versioning concurrency control)的实现原理。</strong></p>
<p>下面我们在执行一个 delete sql：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from t20 where id&#x3D;60;</span><br></pre></td></tr></table></figure>

<p>复制代码</p>
<p>对应的 undo log 变为如下：</p>
<p><img src="https://static001.geekbang.org/infoq/7c/7c17313e068d2d5bc3de22b09b211d1a.png" alt="img"></p>
<p>如上图，实际的行记录不会立刻删除，而是在行记录头信息记录了一个<code>deleted_flag</code>标志位。最终会在 purge 线程 purge undo log 的时候进行实际的删除操作，这个时候 undo log 也会清理掉。</p>
<h3 id="3-11-2、MVCC-实现原理"><a href="#3-11-2、MVCC-实现原理" class="headerlink" title="3.11.2、MVCC 实现原理"></a><em>3.11.2、MVCC 实现原理</em></h3><p>如上图所示，MySQL 只会有一个行记录，但是会把每次执行的 sql 导致行记录的变动，通过 undo log 的形式记录起来，undo log 通过回滚指针连接在一起，这样我们想回溯某一个版本的时候，就可以应用 undo log，回到对应的版本视图了。</p>
<p>我们知道 InnoDB 是支持<code>RC</code>(Read Commit)和<code>RR</code>(Repeatable Read)事务隔离级别的，而这个是通过<code>一致性视图</code>(consistent read view)实现的。</p>
<p>一个事务开启瞬间，所有活跃的事务(未提交)构成了一个视图数组，InnoDB 就是通过这个视图数组来判断行数据是否需要 undo 到指定的版本：</p>
<p><img src="https://static001.geekbang.org/infoq/77/77c97883482820562cee431acae481ed.png" alt="img"></p>
<h5 id="RR-事务隔离级别"><a href="#RR-事务隔离级别" class="headerlink" title="RR 事务隔离级别"></a>RR 事务隔离级别</h5><p>假设我们使用了 <strong>RR 事务隔离级别</strong>。我们看个例子：</p>
<p>如下图，假设 id=60 的记录 a=1</p>
<p><img src="https://static001.geekbang.org/infoq/61/61715b9558ea807ee055b7338605193a.png" alt="img"></p>
<p>事务 C 启动的瞬间，活跃的事务如下图黄色部分所示：</p>
<p><img src="https://static001.geekbang.org/infoq/a4/a451cd8380e83917ce8fde3f30c9f93b.png" alt="img"></p>
<p>也就是对于事务 A、事务 B、事务 C，他们能够看到的数据只有是行记录中的最大事务 ID<code>DATA_TRX_ID</code>&lt;=11 的，如果大于，那么只能通过 undo 进行回滚了。如果 TRX_ID=当前事务 id，也可以看到，即看到自己的改动。</p>
<p>另外有一个需要注意的：</p>
<ul>
<li><strong>在 RR 隔离级别下，当事务更新事务的时候，只能用当前读来获取最新的版本数据来更新，如果当前记录的行锁被其他事务占用，就需要进入所等待；</strong></li>
<li><strong>在 RC 隔离级别下，每个语句执行都会计算出新的一致性视图。</strong></li>
</ul>
<p>所以我们分析上面的例子的执行流程：</p>
<ul>
<li>事务 C 执行 update，执行当前读，拿到的 a=1，然后+1，最终 a=2，同时添加一个 TRX_ID=11 的 undo log；</li>
<li></li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/71/71a6d60e4a95a9ea3d185761b1813fb8.png" alt="img"></p>
<ul>
<li>事务 B 执行 select，使用快照读，记录的 DATA_TRX_ID &gt; 11，所以需要通过 undo log 回滚到 DATA_TRX_ID=11 的版本，所以拿到的 a 是 1；</li>
<li>事务 B 执行 update，需要使用当前读，拿到最新的记录，a=2，然后加 1，最终 a=3；</li>
<li></li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/49/4947edec75db25fea3cf4e4247b55d6f.png" alt="img"></p>
<ul>
<li>事务 B 执行 select，拿到当前最新的版本，为自己的事务 id，所以得到 a=3；</li>
<li>事务 A 执行 select，使用快照读，记录的 DATA_TRX_ID &gt; 11，所以需要通过 undo log 回滚到 DATA_TRX_ID=11 的版本，所以拿到的 a 是 1。</li>
<li>如果是 RC 隔离级别，执行 select 的时候会计算出新的视图，新的视图能够看到的最大事务 ID=14，由于事务 B 还没提交，事务 C 提交了，所以可以得到 a=2：</li>
<li></li>
</ul>
<p><img src="https://static001.geekbang.org/infoq/05/0511164f42c736d04219a23a15575600.png" alt="img"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>数据完整性依靠：redo log</li>
<li>事务隔离级别的实现依靠 MVCC，MVCC 依靠 undo log 实现</li>
<li>IO 性能提升方式：buffer pool 加快查询效率和普通索引更新的效率，log buffer 对日志写的性能提升</li>
<li>查询性能提升依赖于索引，底层用页存储，字段越小页存储越多行记录，查询效率越快；自增字段作为聚集索引可以加快插入操作；</li>
<li>故障恢复：双写缓冲区、redo log</li>
<li>主从同步：binlog</li>
</ul>
<p>本文内容比较多，看完之后需要多梳理，最后大家可以对照着这个思维导图回忆一下，这些内容是否都记住了：</p>
<p><img src="https://static001.geekbang.org/infoq/0c/0c3076a476943d2aa5c3bca36f3c48f4.png" alt="img"></p>
<p><img src="https://static001.geekbang.org/infoq/cc/ccb0ae2eb7184d7109826e07acd3c1b3.png" alt="img"></p>
<hr>
<ul>
<li>转载自：</li>
</ul>
<blockquote>
<p>博客链接： <a target="_blank" rel="noopener" href="https://www.itzhai.com/database/insight-into-the-underlying-architecture-of-mysql-buffer-and-disk.html">https://www.itzhai.com/database/insight-into-the-underlying-architecture-of-mysql-buffer-and-disk.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.itzhai.com/database/insight-into-the-underlying-architecture-of-mysql-buffer-and-disk.html">洞悉MySQL底层架构：游走在缓冲与磁盘之间</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/14/MySQL%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/" data-id="ckr336fos0001e7vyeut0drue" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/07/14/Mysql%20%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Mysql底层原理
        
      </div>
    </a>
  
  
    <a href="/2020/11/12/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/">Python基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/14/Mysql%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/">Mysql架构原理</a>
          </li>
        
          <li>
            <a href="/2021/07/14/java%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%85%A8%E6%B5%81%E7%A8%8B%E5%8F%8AJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">java文件运行全流程及JVM类加载机制</a>
          </li>
        
          <li>
            <a href="/2021/07/14/Mysql%20%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Mysql底层原理</a>
          </li>
        
          <li>
            <a href="/2021/07/14/MySQL%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/">Mysql架构原理</a>
          </li>
        
          <li>
            <a href="/2020/11/12/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 黄自在<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>